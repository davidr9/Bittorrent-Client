/**
 * @author Julie Duncan
 * @author David Rubin
 * @author Rosheen Chaudhry
 */

/*
 * A class represented as a stream of bytes to communicate messages between peers
 */
public class Message {

		/*prefix length*/
		int length;
		
		/*Message ID*/
		byte[] message_id;
		
		 /* ******************************************************************************************/
		 /* keep-alive: <length prefix> is 0. There is no message ID and no payload. 				 */
		 /* These should be sent around once every 2 minutes to prevent peers from closing			 */
		 /*  connections. These only need to be sent if no other messages are sent within a 2-minute */
		 /*  interval.																				 */
		 /* **************************************************************************************** */
		public static final byte keep_alive = -1;
		
		/* choke: <length prefix> is 1 and message ID is 0. There is no payload. */
		public static final byte choke = 0;
		
		/* unchoke: <length prefix> is 1 and the message ID is 1. There is no payload. */
		public static final byte unchoke = 1;
		
		/* interested: <length prefix> is 1 and message ID is 2. There is no payload. */
		public static final byte interested = 2;
		
		/* uninterested: <length prefix> is 1 and message ID is 3. There is no payload.*/
		public static final byte un_interested = 3;
		
		/* have: <length prefix> is 5 and message ID is 4. The payload is a zero-based index of the piece that has just been downloaded and verified.*/
		public static final byte have = 4;
		
		/* request: <length prefix> is 13 and message ID is 6. The payload is as follows: */
		public static final byte request = 6;

		
		/* length prefix is a 4-byte big-endian value and message ID is a single byte.*/
		public Message(int length_prefix, byte[] message_id){
			this.length = length_prefix;
			this.message_id = message_id;
		}
		
		/*Perform handshake
		 * The handshake is the first message transmitted by the client.
		 * <pstrlen> is a string length of <pstr> and it is a single byte.
		 * <pstr> is the string identifier of the protocol.
		 * <reserved> are the 8 reserved bytes, which should all be zeros.
		 * <info_hash> is the 20 byte SHA1 hash of the info key of the torrent. It is the same info_hash transmitted in the tracker requests.
		 * <peer_id> is the 20-byte string used as a unique id for the client. Same peer ID transmitted in tracker request. */
		public static byte[] generateHandShake(byte[] info_hash, byte[] peer_id) {
			
			/* Basic error checking */
			if (info_hash == null || info_hash.length != 20)
				throw new IllegalArgumentException(
						"PeerMessage: Info hash must be 20 bytes.");
			if (peer_id == null || peer_id.length < 20)
				throw new IllegalArgumentException(
						"PeerMessage: Peer ID must be at least 20 bytes.");
			
			byte[] handshake = new byte[] /*Handshaking between peers begins with byte nineteen followed by the string 'BitTorrent protocol'*/
					{ 
					19, 'B', 'i', 't', 'T', 'o', 'r', 'r', 'e', 'n', 't',
					' ', 'p', 'r', 'o','t', 'o', 'c', 'o', 'l',
					/*After the fixed headers are 8 reserved bytes which are set to 0*/
					0, 0, 0, 0, 0, 0, 0, 0,
					/*Next is the 20-byte SHA-1 hash of the bencoded form of the info value from the metainfo (.torrent) file.*/
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					/*The next 20-bytes are the peer id generated by the client*/
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 
					};
			
			/* load the SHA has into its part of the handshake array.*/
			int j=0;
			for(int i = 28; i<info_hash.length; i++){
				handshake[i] = info_hash[j];
				j++;				
			}

			/* load the peer_id into its part of the handshake*/
			int p=0;
			for(int i = 48; i<peer_id.length; i++){
				handshake[i] = info_hash[p];
				p++;				
			}
			
			return handshake;
		}

}
