/**
 * @author Julie Duncan
 * @author David Rubin
 * @author Rosheen Chaudhry
 */

/*
 * A class represented as a stream of bytes to communicate messages between peers
 */
public class Message {

		/*prefix length*/
		int length;
		
		/*Message ID*/
		byte message_id;
		
		byte[] messageSent;
		byte[] messageReceived;
		
		 /* ******************************************************************************************/
		 /* keep-alive: <length prefix> is 0. There is no message ID and no payload. 				 */
		 /* These should be sent around once every 2 minutes to prevent peers from closing			 */
		 /*  connections. These only need to be sent if no other messages are sent within a 2-minute */
		 /*  interval.																				 */
		 /* **************************************************************************************** */
		public static final byte keep_alive = -1;
		
		/* choke: <length prefix> is 1 and message ID is 0. There is no payload. */
		public static final byte choke = 0;
		
		/* unchoke: <length prefix> is 1 and the message ID is 1. There is no payload. */
		public static final byte unchoke = 1;
		
		/* interested: <length prefix> is 1 and message ID is 2. There is no payload. */
		public static final byte interested = 2;
		
		/* uninterested: <length prefix> is 1 and message ID is 3. There is no payload.*/
		public static final byte un_interested = 3;
		
		/* have: <length prefix> is 5 and message ID is 4. The payload is a zero-based index of the piece that has just been downloaded and verified.*/
		public static final byte have = 4;
		
		/*request: <length prefix> is 13 and message ID is 6. The payload is as follows: */
		public static final byte request = 6;

		/*bitfield: <length prefix> is 1 + X (X is pieces/8) and message ID is 5*/
		public static final byte bitfield = 5;

		/*piece: <length prefix> is 9 + x and message ID 7*/
		public static final byte piece = 7;

		
		/* length prefix is a 4-byte big-endian value and message ID is a single byte.*/
		public Message(int length_prefix, byte message_id){
			this.length = length_prefix;
			this.message_id = message_id;
			this.messageSent = new byte[this.length + 4];
			
			switch (message_id){
				case (byte) 0: /*Choke*/
					messageSent = addLengthPrefix(1, messageSent);
					messageSent[4] = (byte) 0;
				case (byte) 1: /*Unchoke*/
					messageSent = addLengthPrefix(1, messageSent);
					messageSent[4] = (byte) 1;
				case (byte) 2: /*Interested*/
					messageSent = addLengthPrefix(1, messageSent);
					messageSent[4] = (byte) 2;
				case (byte) 3: /*Not Interested*/
					messageSent = addLengthPrefix(1, messageSent);
					messageSent[4] = (byte) 3;
				case (byte) 4: /*Have*/
					messageSent = addLengthPrefix(5, messageSent);
					messageSent[4] = (byte) 4;
				case (byte) 6: /*Request*/
					messageSent = addLengthPrefix(13, messageSent);
					messageSent[4] = (byte) 5;
				default: /*Keep-alive*/
					messageSent = addLengthPrefix(0, messageSent);
			}
				
		}
		
		/*Perform handshake
		 * The handshake is the first message transmitted by the client.
		 * <pstrlen> is a string length of <pstr> and it is a single byte.
		 * <pstr> is the string identifier of the protocol.
		 * <reserved> are the 8 reserved bytes, which should all be zeros.
		 * <info_hash> is the 20 byte SHA1 hash of the info key of the torrent. It is the same info_hash transmitted in the tracker requests.
		 * <peer_id> is the 20-byte string used as a unique id for the client. Same peer ID transmitted in tracker request. */
		public static byte[] generateHandShake(byte[] info_hash, byte[] peer_id) {
			
			/* Basic error checking */
			if (info_hash == null || info_hash.length != 20)
				throw new IllegalArgumentException(
						"PeerMessage: Info hash must be 20 bytes.");
			if (peer_id == null || peer_id.length < 20)
				throw new IllegalArgumentException(
						"PeerMessage: Peer ID must be at least 20 bytes.");
			
			byte[] handshake = new byte[] /*Handshaking between peers begins with byte nineteen followed by the string 'BitTorrent protocol'*/
					{ 
					19, 'B', 'i', 't', 'T', 'o', 'r', 'r', 'e', 'n', 't',
					' ', 'p', 'r', 'o','t', 'o', 'c', 'o', 'l',
					/*After the fixed headers are 8 reserved bytes which are set to 0*/
					0, 0, 0, 0, 0, 0, 0, 0,
					/*Next is the 20-byte SHA-1 hash of the b-encoded form of the info value from the metainfo (.torrent) file.*/
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					/*The next 20-bytes are the peer id generated by the client*/
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 
					};
			
			/* load the SHA has into its part of the handshake array.*/
			int j=0;
			int len = 28 + info_hash.length; 
			for(int i = 28; i<len; i++){
				handshake[i] = info_hash[j];
				j++;				
			}

			/* load the peer_id into its part of the handshake*/
			int p=0;
			len = 48 + peer_id.length;
			for(int i = 48; i<peer_id.length; i++){
				handshake[i] = info_hash[p];
				p++;				
			}
		
			return handshake;
		}
		
		public byte[] extractPayload(){
			byte[] payload = new byte[0];
			return payload;
		}
		
		/*Convert length-prefix integer to byte array and add it as the prefix for the message*/
		public static byte[] addLengthPrefix(int base10, byte[] result) {
			result[0] = (byte) (base10 >> 24);
			result[1] = (byte) (base10 >> 16);
			result[2] = (byte) (base10 >> 8);
			result[3] = (byte) (base10);
			return result;
		}
		
		public static void appendPayload(byte[] message, byte id){
			/*Fill in method*/
		}
		
		/*Get the payload from a Have or Request message received from the peer*/
		public byte[] getPayload(){
			byte[] payload = null;
			
			switch (this.message_id){
				case (byte) 4: /*Have message payload is 4 bytes*/
					payload = new byte[4];
					System.arraycopy(this.messageReceived, 5, payload, 0, 4);
					return payload;
				case (byte) 6: /*Request message payload is 12 bytes*/
					payload = new byte[12];
					System.arraycopy(this.messageReceived, 5, payload, 0, 12);
					return payload;
				default: /* Message has no payload*/
					return null;
			}
		}
			

}
